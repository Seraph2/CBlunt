using System;
using System.Collections.Generic;
using System.Linq;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using CBlunt.ANTLR.AutoGeneratedParser;
using System.Reflection;

namespace CBlunt.ANTLR
{
    class SemanticChecker : CBluntBaseVisitor<int>
    {
        private Dictionary<string, VariableProperties> _classScopeVariablesDictionary = new Dictionary<string, VariableProperties>();
        private LinkedList<Dictionary<string, VariableProperties>> _methodScopeLinkedList = new LinkedList<Dictionary<string, VariableProperties>>();

        void SyntaxError(object context, string err)
        {
            var errLine = (int)GetPropertyValue(GetPropertyValue(context, "Start"), "Line");

            Console.WriteLine("Syntax error on line " + errLine + "! " + err);
        }

        public object GetPropertyValue(object obj, string propertyName)
        {
            var objType = obj.GetType();
            var prop = objType.GetProperty(propertyName);

            return prop.GetValue(obj, null);
        }

        public override int VisitStart([NotNull]CBluntParser.StartContext context)
        {
#if DEBUG
            Console.WriteLine("Beginning semantic checking");
            Console.WriteLine("VisitStart");
#endif

            var declarationIter = 0;
            var functionIter = 0;

            /// TODO: Very hackfixy still. Rule: (function | declaration ';')+
            for (var i = 0; i < context.ChildCount; ++i)
            {
                if (context.declaration(declarationIter) != null)
                {
                    Visit(context.declaration(declarationIter));
                    ++declarationIter;
                    continue;
                }
                    
                    
                if (context.function(functionIter) != null)
                {
                    Visit(context.function(functionIter));
                    ++functionIter;
                }
            }

#if DEBUG
            Console.WriteLine("Finished semantic checking");
#endif

            return 0;
        }

        public override int VisitDeclaration([NotNull]CBluntParser.DeclarationContext context)
        {
#if DEBUG
            Console.WriteLine("VisitDeclaration");
#endif
            // Get the variable's type. We do not need to check if the variable's type is correct because that has already been done by the parser
            var variableType = context.variabletype().GetText();

            // Get the variable's name
            var variableName = context.ID().GetText();

            // Get the variable's value if it exists. A context with 4 children is a declaration followed by an assignment
            var variableValue = context.expression()?.GetText();

            // Get the parent index of this visitor
            var parentRuleIndex = context.Parent.RuleIndex;

            // If the parent's rule is "start", the declared variable needs to be added to the class scope, otherwise we add it to the method's scope
            if (parentRuleIndex == CBluntParser.RULE_start)
            {
                // Check whether the variable exists already in the class scope. Give an error if it exists
                if (FindDeclaredVariableInClassScope(variableName))
                {
                    SyntaxError(context, "Variable with name " + variableName + " already exists");
                    return 0;
                }

                // Add the new variable to the class level and create variable properties for it
                _classScopeVariablesDictionary.Add(variableName, new VariableProperties(variableType, variableValue));
            }
            else
            {
                // Check whether the variable already exists in the method scope
                if (FindDeclaredVariableInMethodScope(variableName))
                {
                    SyntaxError(context, "Variable with name " + variableName + " already exists in current or parent scope");
                    return 0;
                }

                // Add the new variable to the last linked list node, and initialize a dictionary to it
                _methodScopeLinkedList.Last.Value.Add(variableName, new VariableProperties(variableType, variableValue));
            }

            // If no expression is found, simply return as the variable cannot be type-checked against
            if (context.expression() == null)
                return 0;

            // Simplify retrieval of the expression's parameter using a variable. Note that this does not properly handle the grammar's way, as I intentionally omit "calculation*" for testing purposes
            var contextExpressionParameter = context.expression().parameter();

            /// TODO: It may be necessary to determine a better way to do this, potentially utilizing visitor more correctly as this MAY complicate things later
            string foundParameterType = "";

            // Get the name of the expected parameter for potential error output further below
            if (contextExpressionParameter.STRING() != null)
                foundParameterType = "text";

            if (contextExpressionParameter.NUMBER() != null)
                foundParameterType = "number";

            if (contextExpressionParameter.truth() != null)
                foundParameterType = "bool";

            if (contextExpressionParameter.ID() != null)
            {
                var variablePropeties = GetDeclaredVariable(contextExpressionParameter.ID().GetText());

                if (variablePropeties == null)
                    return 1;

                foundParameterType = variablePropeties.Type;
            }

            if (contextExpressionParameter.functioncall() != null)
            {
                // Helper variables for accessing deeper visitors
                var functionCall = contextExpressionParameter.functioncall();
                var functionCallParameter = functionCall.parameter();

                // The name of the method
                var methodName = contextExpressionParameter.functioncall().ID().GetText();

                // If the visitor returns 1, there was a problem. Stop declaration check.
                if (Visit(contextExpressionParameter.functioncall()) == 1)
                    return 1;

                // Set the expected parameter type to the method's properties
                var methodProperties = GetMethodProperties(methodName);

                foundParameterType = methodProperties.Type;
            }

            // Check the variable's type with the found type
            if (variableType != foundParameterType)
            {
                SyntaxError(context, "Expected " + variableType + ", got " + foundParameterType);
                return 1;
            }

            return 0;
        }

        public override int VisitFunction([NotNull]CBluntParser.FunctionContext context)
        {
#if DEBUG
            Console.WriteLine("VisitFunction");
#endif

            // Create a new scope to the linked list
            _methodScopeLinkedList.AddLast(new Dictionary<string, VariableProperties>());

            // Get the method's type
            var methodType = context.functiontype().GetText();

            // Get the method's name
            var methodName = context.ID(0).GetText();

            // Create the actual properties for the method
            MethodProperties methodProperties = new MethodProperties
            {
                // Set the type of the method
                Type = methodType,

                // Create the parameter types list for parsing of the method's parameters
                ParameterTypes = new List<string>()
            };

            // Check whether the method contains parameters. If so, add the parameter types to the methodProperties and add the variables
            // to the main scope of the method
            if (context.children.Count > 5)
            {
                var parameterObjects = context.children.Count - 5;

                // Start from 3 as that is the first potential parameter. Addition-operator 2 on i to skip the comma
                for (int i = 3; i < context.children.Count - 2; i += 2)
                {
                    var parameterType = context.children[i].GetText();
                    var parameterName = context.children[++i].GetText();

                    // Add the parameter type to the list of parameter types
                    methodProperties.ParameterTypes.Add(parameterType);

                    // Add the variable along with properties to the method scope
                    _methodScopeLinkedList.Last.Value.Add(parameterName, new VariableProperties(parameterType));
                }
            }


            /// TODO: Check also if method exists already which will have been done if it has been discovered earlier
            /// If so, do not override the dictionary, simply check the methodProperties against the discovered one

            /// TODO: If method has already existed due to discovery nodes, now verify if discovery nodes were true

            // Visit the block of the function
            Visit(context.block());

            // Remove the scope
            _methodScopeLinkedList.RemoveLast();

            return 0;
        }

        public override int VisitBlock([NotNull]CBluntParser.BlockContext context)
        {
#if DEBUG
            Console.WriteLine("VisitBlock");
#endif

             // Iterate over all potential statements in the block. There can be 0 statements here
            for (var i = 0; i < context.ChildCount; ++i)
            {
                if (context.statement(i) != null)
                    Visit(context.statement(i));
            }

            return 0;
        }

        public override int VisitExpression([NotNull]CBluntParser.ExpressionContext context)
        {
#if DEBUG
            Console.WriteLine("VisitExpression");
#endif
            if (context.parameter() != null)
                Visit(context.parameter());

            /*if (context.calculation() != null)
                Visit(context.calculation(0));*/

            return 0;
        }

        public override int VisitParameter([NotNull]CBluntParser.ParameterContext context)
        {
#if DEBUG
            Console.WriteLine("VisitParameter");
#endif

            if (context.ID() != null)
            {
                
            }

            return 0;
        }

        public override int VisitVariableedit([NotNull] CBluntParser.VariableeditContext context)
        {
#if DEBUG
            Console.WriteLine("VisitVariableedit");
#endif
            // The name of the variable
            var variableName = context.ID().GetText();

            // The operator type (For example: = += /= so on)
            var operatorType = context.equals().GetText();

            // The assignment value
            var assignmentValue = context.expression().GetText();

            /// TODO: USE UTILITY METHOD

            // First iterate over the current scope and all previous scopes
            var currNode = _methodScopeLinkedList.Last;
            var variableExists = false;

            // The properties of the variable we found
            VariableProperties variableProperties = null;

            // In order to edit a variable, we first need to check the method's scopes. If it was not found here, the class scope is checked
            while (true)
            {
                // Get the value (aka. dictionary) of the scope
                var scopeVariables = currNode.Value;

                // Stop the loop if the variable has been found in the current scope
                if (scopeVariables.ContainsKey(variableName))
                {
                    variableProperties = scopeVariables[variableName];
                    variableExists = true;
                    break;
                }

                // If there exists no previous node, stop the loop
                if (currNode.Previous == null)
                    break;

                currNode = currNode.Previous;
            }

            // If the variable was still not found after checking the method scope, we check the class scope
            if (!variableExists)
            {
                if (_classScopeVariablesDictionary.ContainsKey(variableName))
                {
                    variableProperties = _classScopeVariablesDictionary[variableName];
                    variableExists = true;
                }
            }

            // If the variable still was not found, cause an error
            if (!variableExists)
            {
                SyntaxError(context, "Variable with name " + variableName + " cannot be assigned a value as it does not exist.");
                return 0;
            }

            // Get the expected assignment value, aka the value we expect the variable to be assigned
            var contextExpressionParameter = context.expression().parameter();
            var assignmentType = "";

            if (contextExpressionParameter.STRING() != null)
                assignmentType = "text";

            if (contextExpressionParameter.NUMBER() != null)
                assignmentType = "number";

            if (contextExpressionParameter.truth() != null)
                assignmentType = "bool";

            if (contextExpressionParameter.ID() != null)
            {
                var assignmentVariableProperties = GetDeclaredVariable(contextExpressionParameter.ID().GetText());

                if (assignmentVariableProperties == null)
                    return 1;

                // Determine whether the variable we are trying to assign has been initialized
                // We can assign an initialized variable to an uninitialized, but not an uninitialized variable to an initialized variable
                if (!assignmentVariableProperties.Initialized)
                {
                    SyntaxError(context, "Cannot assign the value of variable " + contextExpressionParameter.ID().GetText() + " to variable " + variableName + " as it has not been initialized yet.");
                    return 1;
                }

                assignmentType = assignmentVariableProperties.Type;
            }

            if (contextExpressionParameter.functioncall() != null)
            {
                // Visit the functioncall for potential recursive handling
                if (Visit(contextExpressionParameter.functioncall()) == 1)
                    return 1;

                var methodProperties = GetMethodProperties(contextExpressionParameter.functioncall().ID().GetText());

                if (methodProperties == null)
                    return 1;

                assignmentType = methodProperties.Type;
            }

            switch (operatorType)
            {
                // Always allow default assignment
                case "=":
                    break;

                case "+=":
                    if (assignmentType != "number")
                    {
                        SyntaxError(context, "Cannot use addition assignment operator on a type " + assignmentType);
                        return 0;
                    }
                    break;

                case "-=":
                    if (assignmentType != "number")
                    {
                        SyntaxError(context, "Cannot use subtraction assignment operator on a type " + assignmentType);
                        return 0;
                    }
                    break;

                case "*=":
                    if (assignmentType != "number")
                    {
                        SyntaxError(context, "Cannot use multiplication assignment operator on a type " + assignmentType);
                        return 0;
                    }
                    break;

                case "/=":
                    if (assignmentType != "number")
                    {
                        SyntaxError(context, "Cannot use division assignment operator on a type " + assignmentType);
                        return 0;
                    }
                    break;
            }

            // Now test if this variable's type is the type it tries to assign
            if (variableProperties.Type != assignmentType)
            {
                SyntaxError(context, "Variable " + variableName + " is of type " + variableProperties.Type + ", cannot assign it a value of type " + assignmentType);
                return 0;
            }

            // Finally, set the new value of the variable. This is set out of sheer principle
            variableProperties.Value = assignmentValue;

            return base.VisitVariableedit(context);
        }

        public override int VisitStatement([NotNull] CBluntParser.StatementContext context)
        {
#if DEBUG
            Console.WriteLine("VisitStatement");
#endif
            /// TODO: Iterate as the rule requires it
            //Visit(context.functioncall());

            return base.VisitStatement(context);
        }

        public override int VisitFunctioncall([NotNull] CBluntParser.FunctioncallContext context)
        {
#if DEBUG
            Console.WriteLine("VisitFunctioncall");
#endif
            
            // The name of the method to call
            var methodName = context.ID().GetText();

            // This rule denotes a method call with nothing to return. Simple check to see if the method even exists.
            if (!FindMethod(methodName))
            {
                SyntaxError(context, "Attempt to call method " + methodName + " that does not exist");
                return 1;
            }

            // Get the method's properties
            var methodProperties = SymbolTable.MethodDictionary[methodName];

            // Check if the method takes parameters. If the functioncall sends a parameter and the method does not take any, stop and give error
            if (context.parameter(0) != null)
            {
                if (methodProperties.ParameterTypes.Count == 0)
                {
                    SyntaxError(context, "Method with name " + methodName + " does not take any parameters");
                    return 1;
                }
            }

            // Get the nice name for the method
            var methodNiceName = GetMethodNiceName(methodName, methodProperties.ParameterTypes);

            // Compare the method's parameters with the found parameters to see whether they match
            int parameterIter = 0;
            while (context.parameter(parameterIter) != null)
            {
                var parameterType = "";
                var parameterCount = parameterIter + 1;

                var functionCallParameterType = context.parameter(parameterIter);

                if (functionCallParameterType.STRING() != null)
                    parameterType = "text";

                if (functionCallParameterType.NUMBER() != null)
                    parameterType = "number";

                if (functionCallParameterType.truth() != null)
                    parameterType = "bool";

                
                // Get the variable, if null we return. Otherwise the variable's type is assigned
                if (functionCallParameterType.ID() != null)
                {
                    var variableProperties = GetDeclaredVariable(functionCallParameterType.GetText());

                    if (variableProperties == null)
                        return 1;

                    parameterType = variableProperties.Type;
                }
                    
                if (functionCallParameterType.functioncall() != null)
                {
                    // Handle functioncall recursively
                    if (Visit(functionCallParameterType.functioncall()) == 1)
                        return 1;

                    var methodHere = GetMethodProperties(functionCallParameterType.functioncall().ID().GetText());

                    if (methodHere == null)
                        return 1;

                    parameterType = methodHere.Type;
                }

                // If nothing matched, something is seriously wrong
                if (parameterType == "")
                {
                    SyntaxError(context, "Nothing matched parameter number " + parameterCount + " for method " + methodNiceName);
                    return 1;
                }

                if (methodProperties.ParameterTypes.Count < parameterCount)
                {
                    SyntaxError(context, "Method " + methodNiceName + " does not take " + parameterCount + " parameters");
                    return 1;
                }

                var expectedMethodParameterType = methodProperties.ParameterTypes[parameterIter];

                if (expectedMethodParameterType != parameterType)
                {
                    SyntaxError(context, "Method " + methodNiceName + " got type " + parameterType + " as parameter number " + parameterCount + ", expected " + expectedMethodParameterType);
                    return 1;
                }

                ++parameterIter;
            }

            if (methodProperties.ParameterTypes.Count > parameterIter)
            {
                SyntaxError(context, "Method " + methodNiceName + " got " + parameterIter + " parameters, expected " + methodProperties.ParameterTypes.Count);
                return 1;
            }

            return base.VisitFunctioncall(context);
        }


        /*
         * Get a method as a nice name
         */
         string GetMethodNiceName(string methodName, List<string> methodParameters)
        {
            // Add a parenthese
            methodName += "(";


            // Only perform iteration if there actually exists parameters to this function
            if (methodParameters.Count > 0)
            {
                // Iterate over all types of found parameters, write its type along with a comma
                foreach (var paramType in methodParameters)
                {
                    methodName += paramType + ",";
                }

                // Remove the last comma
                methodName = methodName.Remove(methodName.Length - 1);
            }

            methodName += ")";

            return methodName;
        }


        /*
         * Get a method's properties
         */
        MethodProperties GetMethodProperties(string methodName)
        {
            if (SymbolTable.MethodDictionary.ContainsKey(methodName))
                return SymbolTable.MethodDictionary[methodName];

            return null;
        }

        /*
         * Get a declared variable in method scope first, then the class scope
         */
        VariableProperties GetDeclaredVariable(string variableName)
        {
            VariableProperties variableProperties = null;

            // Get the variable's properties from method scope
            variableProperties = GetDeclaredVariableInMethodScope(variableName);

            // If the variable's properties was not found, try the class scope
            if (variableProperties == null)
                variableProperties = GetDeclaredVariableInClassScope(variableName);

            return variableProperties;
        }

        VariableProperties GetDeclaredVariableInMethodScope(string variableName)
        {
            // Get the last node to iterate backwards over the linked list. Note that it is impossible for the linked list to be empty initially
            var currNode = _methodScopeLinkedList.Last;

            VariableProperties variableProperties = null;

            // This loop will ALWAYS end, as it is certain there will exist at least 1 node, and a node will always have an end, aka. previous == null. Should there somehow not exist such a node (for debugging maybe), it will give an error
            // We need to iterate over all previous scopes and see if the variable is declared as that is not allowed in C#
            while (true)
            {
                // Get the value (aka. dictionary) of the scope
                var scopeVariables = currNode.Value;

                // Stop the loop if the variable has been found in the current scope
                if (scopeVariables.ContainsKey(variableName))
                {
                    variableProperties = scopeVariables[variableName];
                    break;
                }

                // If there exists no previous node, stop the loop
                if (currNode.Previous == null)
                    break;

                currNode = currNode.Previous;
            }

            // Simply return as variable properties may or may not be null
            return variableProperties;
        }

        VariableProperties GetDeclaredVariableInClassScope(string variableName)
        {
            // Create variableproperties file for storing the potential class variable
            VariableProperties variableProperties = null;

            if (_classScopeVariablesDictionary.ContainsKey(variableName))
                variableProperties = _classScopeVariablesDictionary[variableName];

            // Return either null or the variable's properties
            return variableProperties;
        }

        /*
         *  Determine whether a method exists.
         */
        bool FindMethod(string methodName)
        {
            return GetMethodProperties(methodName) != null;
        }

        /*
         * A helper method for checking if a method is declared in class scope
         */
        bool FindDeclaredVariable(string variableName)
        {
            // Check method scope first
            if (FindDeclaredVariableInMethodScope(variableName))
                return true;

            // Then check the class scope
            if (FindDeclaredVariableInClassScope(variableName))
                return true;

            // If not found in both of them, variable could not be found
            return false;
        }

        /*
         * A helper metohod for checking if a method is declared in class scope
         */
        bool FindDeclaredVariableInClassScope(string variableName)
        {
            return GetDeclaredVariableInClassScope(variableName) != null;
        }

        /*
         * A method for simplifying finding declared variables in the scope of a method (skipping class scope)
         */
        bool FindDeclaredVariableInMethodScope(string variableName)
        {
            return GetDeclaredVariableInMethodScope(variableName) != null;
        }
    }
}