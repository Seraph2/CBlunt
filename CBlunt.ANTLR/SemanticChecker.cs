using System;
using System.Collections.Generic;
using System.Linq;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using CBlunt.ANTLR.AutoGeneratedParser;
using System.Reflection;

namespace CBlunt.ANTLR
{
    class SemanticChecker : CBluntBaseVisitor<int>
    {
        private readonly Dictionary<string, VariableProperties> _classScopeVariablesDictionary = new Dictionary<string, VariableProperties>();
        private readonly LinkedList<Dictionary<string, VariableProperties>> _methodScopeLinkedList = new LinkedList<Dictionary<string, VariableProperties>>();
        private string _currentMethodName = "";
        private ExpressionStore _expressionStore = new ExpressionStore();

        void SyntaxError(object context, string err)
        {
            var errLine = (int)GetPropertyValue(GetPropertyValue(context, "Start"), "Line");

            Console.WriteLine("Syntax error on line " + errLine + "! " + err);
        }

        public object GetPropertyValue(object obj, string propertyName)
        {
            var objType = obj.GetType();
            var prop = objType.GetProperty(propertyName);

            return prop.GetValue(obj, null);
        }

        public override int VisitStart([NotNull]CBluntParser.StartContext context)
        {
#if DEBUG
            Console.WriteLine("Beginning semantic checking");
            Console.WriteLine("VisitStart");
#endif

            // Determine whether the entry point exists
            var mainMethodProperties = GetMethodProperties("Main");

            if (mainMethodProperties == null)
            {
                Console.WriteLine("Syntax error! There must exists a method with following properties: void Main() { }");
                return 1;
            }

            if (mainMethodProperties.Type != "void")
            {
                Console.WriteLine("Syntax error! There must exists a method with following properties: void Main() { }");
                return 1;
            }

#if DEBUG
            Console.WriteLine("Finished semantic checking");
#endif

            return base.VisitStart(context);
        }

        public override int VisitDeclaration([NotNull]CBluntParser.DeclarationContext context)
        {
#if DEBUG
            Console.WriteLine("VisitDeclaration");
#endif
            // Get the variable's type. We do not need to check if the variable's type is correct because that has already been done by the parser
            var variableType = context.variabletype().GetText();

            // Get the variable's name
            var variableName = context.ID().GetText();

            // Get the variable's value if it exists. A context with 4 children is a declaration followed by an assignment
            var variableValue = context.expression()?.GetText();

            // Get the parent index of this visitor
            var parentRuleIndex = context.Parent.RuleIndex;

            // If the parent's rule is "start", the declared variable needs to be added to the class scope, otherwise we add it to the method's scope
            if (parentRuleIndex == CBluntParser.RULE_start)
            {
                // Check whether the variable exists already in the class scope. Give an error if it does so
                if (FindDeclaredVariableInClassScope(variableName))
                {
                    SyntaxError(context, "Variable with name " + variableName + " already exists");
                    return 1;
                }
            }
            else
            {
                // Check whether the variable already exists in the method scope
                if (FindDeclaredVariableInMethodScope(variableName))
                {
                    SyntaxError(context, "Variable with name " + variableName + " already exists in current or parent scope");
                    return 1;
                }
            }

            // If no expression is found, simply create the variable and return as the variable cannot be type-checked against
            // Example: text a;
            if (context.expression() == null)
            {
                CreateVariable(parentRuleIndex, variableName, variableType, variableValue);
                return 0;
            }

            // Simplify retrieval of the expression's parameter using a variable. Note that this does not properly handle the grammar's way, as I intentionally omit "calculation*" for testing purposes
            var contextExpressionParameter = context.expression().parameter();

            /// TODO: It may be necessary to determine a better way to do this, potentially utilizing visitor more correctly as this MAY complicate things later
            string foundParameterType = "";

            // Get the name of the expected parameter for potential error output further below
            if (contextExpressionParameter.STRING() != null)
                foundParameterType = "text";

            if (contextExpressionParameter.NUMBER() != null)
                foundParameterType = "number";

            if (contextExpressionParameter.truth() != null)
                foundParameterType = "bool";

            if (contextExpressionParameter.ID() != null)
            {
                var variablePropeties = GetDeclaredVariable(contextExpressionParameter.ID().GetText());

                if (variablePropeties == null)
                    return 1;

                if (!variablePropeties.Initialized)
                {
                    SyntaxError(context, "Cannot assign the value of variable " + contextExpressionParameter.ID().GetText() + " to variable " + variableName + " as it has not been initialized yet.");
                    return 1;
                }

                foundParameterType = variablePropeties.Type;
            }

            if (contextExpressionParameter.functioncall() != null)
            {
                // The name of the method
                var methodName = contextExpressionParameter.functioncall().ID().GetText();

                // If the visitor returns 1, there was a problem. Stop declaration check.
                if (Visit(contextExpressionParameter.functioncall()) == 1)
                    return 1;

                // Set the expected parameter type to the method's properties
                var methodProperties = GetMethodProperties(methodName);

                if (methodProperties == null)
                {
                    SyntaxError(context, "Attempt to get method " + methodName + " that does not exist");
                    return 1;
                }

                foundParameterType = methodProperties.Type;
            }

            // Check the variable's type against the found type
            if (variableType != foundParameterType)
            {
                SyntaxError(context, "Expected " + variableType + ", got " + foundParameterType);
                return 1;
            }

            CreateVariable(parentRuleIndex, variableName, variableType, variableValue);

            return base.VisitDeclaration(context);
        }

        public override int VisitFunction([NotNull]CBluntParser.FunctionContext context)
        {
#if DEBUG
            Console.WriteLine("VisitFunction");
#endif

            // Create a new scope to the linked list
            _methodScopeLinkedList.AddLast(new Dictionary<string, VariableProperties>());

            // Get the method's type
            var methodType = context.functiontype().GetText();

            // Get the method's name
            var methodName = context.ID(0).GetText();

            // Create the actual properties for the method
            MethodProperties methodProperties = new MethodProperties
            {
                // Set the type of the method
                Type = methodType,

                // Create the parameter types list for parsing of the method's parameters
                ParameterTypes = new List<string>()
            };

            // Check whether the method contains parameters. If so, add the parameter types to the methodProperties and add the variables
            // to the main scope of the method
            for (int i = 0; i < context.variabletype().Count(); ++i)
            {
                // Get the parameter's type
                var parameterType = context.variabletype(i).GetText();

                // Get the parameter's name. This is +1 due to that the first ID is the method's name
                var parameterName = context.ID(i + 1).GetText();

                // Add the parameter type to the list of parameter types
                methodProperties.ParameterTypes.Add(parameterType);

                // All parameters are guranteed to be initialized, set the initialized flag
                var variableProperties = new VariableProperties(parameterType)
                {
                    Initialized = true
                };

                // Add the variable along with properties to the method scope
                _methodScopeLinkedList.Last.Value.Add(parameterName, variableProperties);
            }

            // Detect if there exists a return in a method that is not of type void. Void can return too but it's not mandatory
            var blockStatement = context.block().statement();

            // In the initial scope of the method, check whether there exists at least one return. Error if there exists multiple
            int returnCount = 0;

            for (int i = 0; i < blockStatement.Count(); ++i)
            {
                // Skip non-function returns
                if (context.block().statement(i).functionreturn() == null)
                    continue;

                // Cannot break here as there MAY exist multiple returns
                ++returnCount;

                // Check for void: it cannot return anything
                if (context.block().statement(i).functionreturn().expression() != null && methodType == "void")
                {
                    SyntaxError(context, "Void methods cannot return values");
                    return 1;
                }

                // Check for non-void: it MUST return something
                if (context.block().statement(i).functionreturn().expression() == null && methodType != "void")
                {
                    SyntaxError(context, "Method " + methodName + " with type " + methodType + " must return a value");
                    return 1;
                }

                // If there exists multiple returns, there is a problem. This accounts for both void and other types
                if (returnCount > 1)
                {
                    SyntaxError(context, "Method " + methodName + " with type " + methodType + " cannot return multiple times in its method scope");
                    return 1;
                }
            }

            // If there exists no return and it is NOT a method of type void, output an error
            if (returnCount == 0 && methodType != "void")
            {
                SyntaxError(context, "Method " + methodName + " with type " + methodType + " does not return a type " + methodType);
                return 1;
            }

            _currentMethodName = methodName;

            // Visit the block of the method
            Visit(context.block());

            // After the function has finished, remove the scope
            _methodScopeLinkedList.RemoveLast();

            _currentMethodName = "";

            return 0;
        }

        public override int VisitExpression([NotNull]CBluntParser.ExpressionContext context)
        {
#if DEBUG
            Console.WriteLine("VisitExpression");
#endif

            _expressionStore.ExpressionTypes.AddLast("test");

            var calculationCount = context.calculation().Count();

            // No calculation, grab parameter and set correct return-type
            if (calculationCount == 0)
            {
                var parameter = context.parameter();
                var assignmentType = GetParameterType(context, parameter);

                Console.WriteLine("calc count = 0: " + assignmentType);

                return 0;
            }

            Console.WriteLine("Calc count: " + calculationCount);
            Console.WriteLine(context.parameter().GetText());

            for (int i = 0; i < calculationCount; ++i)
            {
                if (context.calculation(i).parameter() != null)
                {
                    Console.WriteLine(GetParameterType(context, context.calculation(i).parameter()));

                    Console.WriteLine(context.calculation(i).parameter().GetText());
                }

                if (context.calculation(i).expression() != null)
                {
                    Visit(context.calculation(i).expression());
                }
            }

            return 0;
        }

        public override int VisitParameter([NotNull]CBluntParser.ParameterContext context)
        {
#if DEBUG
            Console.WriteLine("VisitParameter");
#endif

            if (context.ID() != null)
            {
                
            }

            return 0;
        }

        public override int VisitVariableedit([NotNull] CBluntParser.VariableeditContext context)
        {
#if DEBUG
            Console.WriteLine("VisitVariableedit");
#endif
            // The name of the variable
            var variableName = context.ID().GetText();

            // The operator type (For example: = += /= so on)
            var operatorType = context.equals().GetText();

            // The assignment value
            var assignmentValue = context.expression().GetText();

            /// TODO: USE UTILITY METHOD

            // First iterate over the current scope and all previous scopes
            var currNode = _methodScopeLinkedList.Last;

            // The properties of the variable we found
            VariableProperties variableProperties = null;

            variableProperties = GetDeclaredVariable(variableName);

            if (variableProperties == null)
            {
                SyntaxError(context, "Variable with name " + variableName + " cannot be assigned a value as it does not exist");
                return 1;
            }

            // Get the expected assignment value, aka the value we expect the variable to be assigned
            var expressionParameter = context.expression().parameter();
            var assignmentType = "";

            if (expressionParameter.STRING() != null)
                assignmentType = "text";

            if (expressionParameter.NUMBER() != null)
                assignmentType = "number";

            if (expressionParameter.truth() != null)
                assignmentType = "bool";

            if (expressionParameter.ID() != null)
            {
                var assignmentVariableProperties = GetDeclaredVariable(expressionParameter.ID().GetText());

                if (assignmentVariableProperties == null)
                {
                    SyntaxError(context, "Cannot assign the value of variable " + expressionParameter.ID().GetText() + " to variable " + variableName + " as it does not exist");
                    return 1;
                }

                // Determine whether the variable we are trying to assign has been initialized
                // We can assign an initialized variable to an uninitialized, but not an uninitialized variable to an initialized variable
                if (!assignmentVariableProperties.Initialized)
                {
                    SyntaxError(context, "Cannot assign the value of variable " + expressionParameter.ID().GetText() + " to variable " + variableName + " as it has not been initialized yet");
                    return 1;
                }

                // If all checks passes, grab the assignment type
                assignmentType = assignmentVariableProperties.Type;
            }

            if (expressionParameter.functioncall() != null)
            {
                // Visit the functioncall for potential recursive handling. If it returns 1 it means that an error has occured and
                // checking should stop
                if (Visit(expressionParameter.functioncall()) == 1)
                    return 1;

                /// TODO: Maybe move the part below this up above the Visit
                var methodProperties = GetMethodProperties(expressionParameter.functioncall().ID().GetText());

                if (methodProperties == null)
                {
                    SyntaxError(context, "Method with name " + expressionParameter.functioncall().ID().GetText() + " does not exist");
                    return 1;
                }

                assignmentType = methodProperties.Type;
            }

            switch (operatorType)
            {
                // Always allow default assignment
                case "=":
                    break;

                case "+=":
                    if (assignmentType != "number")
                    {
                        SyntaxError(context, "Cannot use addition assignment operator on a type " + assignmentType);
                        return 1;
                    }
                    break;

                case "-=":
                    if (assignmentType != "number")
                    {
                        SyntaxError(context, "Cannot use subtraction assignment operator on a type " + assignmentType);
                        return 1;
                    }
                    break;

                case "*=":
                    if (assignmentType != "number")
                    {
                        SyntaxError(context, "Cannot use multiplication assignment operator on a type " + assignmentType);
                        return 1;
                    }
                    break;

                case "/=":
                    if (assignmentType != "number")
                    {
                        SyntaxError(context, "Cannot use division assignment operator on a type " + assignmentType);
                        return 1;
                    }
                    break;
            }

            // Now test if this variable's type is the type we are trying to assign
            if (variableProperties.Type != assignmentType)
            {
                SyntaxError(context, "Variable " + variableName + " is of type " + variableProperties.Type + ", cannot assign it a value of type " + assignmentType);
                return 1;
            }

            // If all checks passes, the variable will also be initialized
            variableProperties.Initialized = true;

            return base.VisitVariableedit(context);
        }

        public override int VisitStatement([NotNull] CBluntParser.StatementContext context)
        {
#if DEBUG
            Console.WriteLine("VisitStatement");
#endif
            /// TODO: Iterate as the rule requires it
            //Visit(context.functioncall());

            return base.VisitStatement(context);
        }

        public override int VisitFunctioncall([NotNull] CBluntParser.FunctioncallContext context)
        {
#if DEBUG
            Console.WriteLine("VisitFunctioncall");
#endif
            
            // The name of the method to call
            var methodName = context.ID().GetText();

            // Get the amout of expressions
            var expressionCount = context.expression().Count();

            // Get the method's properties
            var methodProperties = GetMethodProperties(methodName);

            // This rule denotes a method call with nothing to return. Simple check to see if the method even exists.
            if (methodProperties == null)
            {
                SyntaxError(context, "Attempt to call method " + methodName + " that does not exist");
                return 1;
            }

            // If there exists expressions, and the method does not actually take any parameters, stop and give syntax error
            if (expressionCount > 0 && methodProperties.ParameterTypes.Count == 0)
            {
                SyntaxError(context, "Method with name " + methodName + " does not take any parameters");
                return 1;
            }

            // Get the nice name for the method
            var methodNiceName = GetMethodNiceName(methodName, methodProperties.ParameterTypes);

            if (methodProperties.ParameterTypes.Count != expressionCount)
            {
                SyntaxError(context, "Method " + methodNiceName + " got " + expressionCount + " parameters, expected " + methodProperties.ParameterTypes.Count);
                return 1;
            }

            // Compare the method's parameters with the found parameters to see whether they match
            for (int i = 0; i < context.expression().Count(); ++i)
            {
                var parameterType = "";
                var parameterCount = i + 1;

                /// TODO: Handle calculation recursively
                var functionCallParameterType = context.expression(i).parameter();

                if (functionCallParameterType.STRING() != null)
                    parameterType = "text";

                if (functionCallParameterType.NUMBER() != null)
                    parameterType = "number";

                if (functionCallParameterType.truth() != null)
                    parameterType = "bool";

                // Get the variable, if null we return. Otherwise the variable's type is assigned
                if (functionCallParameterType.ID() != null)
                {
                    // Grab the variable's properties
                    var variableProperties = GetDeclaredVariable(functionCallParameterType.GetText());

                    // Determine if it exists
                    if (variableProperties == null)
                    {
                        SyntaxError(context, "Passed variable " + functionCallParameterType.GetText() + " as parameter " + parameterCount + " to method " + methodNiceName + " does not exist");
                        return 1;
                    }

                    // Check if the variable has been initialized
                    if (!variableProperties.Initialized)
                    {
                        SyntaxError(context, "Cannot pass variable " + functionCallParameterType.GetText() + " to method " + methodName + " as it has not been initialized yet.");
                        return 1;
                    }

                    parameterType = variableProperties.Type;
                }
                
                if (functionCallParameterType.functioncall() != null)
                {
                    // Handle functioncall recursively
                    if (Visit(functionCallParameterType.functioncall()) == 1)
                        return 1;

                    var methodHere = GetMethodProperties(functionCallParameterType.functioncall().ID().GetText());

                    /*
                    /// TODO: CORRECT ERROR HERE, DETERMINE WHETHER THIS IS ALREADY HANDLED IN FUNCTIONCALL
                    if (methodHere == null)
                        return 1;*/

                    parameterType = methodHere.Type;
                }

                // If nothing matched, we got a problem
                if (parameterType == "")
                {
                    SyntaxError(context, "Nothing matched parameter number " + parameterCount + " for method " + methodNiceName);
                    Console.WriteLine("Houston, we got a problem");
                    return 1;
                }

                /// TODO: Potentially != here instead
                if (methodProperties.ParameterTypes.Count < parameterCount)
                {
                    SyntaxError(context, "Method " + methodNiceName + " does not take " + parameterCount + " parameters");
                    return 1;
                }

                // Get the expected parameter type from the method's properties
                var expectedParameterType = methodProperties.ParameterTypes[i];

                // If it is not equal to the retrieved parameter type, be it variable, functioncall etc, an error is imminent
                if (expectedParameterType != parameterType)
                {
                    SyntaxError(context, "Method " + methodNiceName + " got type " + parameterType + " as parameter number " + parameterCount + ", expected " + expectedParameterType);
                    return 1;
                }
            }

            return base.VisitFunctioncall(context);
        }

        public override int VisitFunctionreturn([NotNull] CBluntParser.FunctionreturnContext context)
        {
            /// TODO: Evaluate here whatever is attempted to return is correct according to the method's type

            return base.VisitFunctionreturn(context);
        }

        /*
         * Create a variable in its appropriate scope
         */
        void CreateVariable(int parentRuleIndex, string variableName, string variableType, string variableValue)
        {
            // Add the variable to the appropriate place
            if (parentRuleIndex == CBluntParser.RULE_start)
            {
                // Add the new variable to the class level and create variable properties for it
                _classScopeVariablesDictionary.Add(variableName, new VariableProperties(variableType, variableValue));
            }
            else
            {
                // Add the new variable to the last LinkedList node, and initialize a dictionary to it
                _methodScopeLinkedList.Last.Value.Add(variableName, new VariableProperties(variableType, variableValue));
            }
        }

        /*
         * Get a method as a nice name, ex: MethodHere(number,text,bool)
         */
        string GetMethodNiceName(string methodName, List<string> methodParameters)
        {
            // Add a parenthese
            methodName += "(";

            // Only perform iteration if there actually exists parameters to this function
            if (methodParameters.Count > 0)
            {
                // Iterate over all types of found parameters, write its type along with a comma
                foreach (var paramType in methodParameters)
                    methodName += paramType + ",";

                // Remove the last comma
                methodName = methodName.Remove(methodName.Length - 1);
            }

            methodName += ")";

            return methodName;
        }

        /*
         * Get a method's properties
         */
        MethodProperties GetMethodProperties(string methodName)
        {
            if (SymbolTable.MethodDictionary.ContainsKey(methodName))
                return SymbolTable.MethodDictionary[methodName];

            return null;
        }

        /*
         * Get a declared variable in method scope first, then the class scope
         */
        VariableProperties GetDeclaredVariable(string variableName)
        {
            // Get the variable's properties from method scope
            VariableProperties variableProperties = GetDeclaredVariableInMethodScope(variableName);

            // If the variable's properties was not found, try the class scope
            if (variableProperties == null)
                variableProperties = GetDeclaredVariableInClassScope(variableName);

            // Return the variable
            return variableProperties;
        }

        VariableProperties GetDeclaredVariableInMethodScope(string variableName)
        {
            // Get the last node to iterate backwards over the linked list. Note that it is impossible for the linked list to be empty initially
            var currNode = _methodScopeLinkedList.Last;

            // Create variable properties variable for storing the output
            VariableProperties variableProperties = null;

            // This loop will ALWAYS end, as it is certain there will exist at least 1 node, and a node will always have an end, aka. previous == null. Should there somehow not exist such a node (for debugging maybe), it will give an error
            // We need to iterate over all previous scopes and see if the variable is declared as that is not allowed in C#
            while (true)
            {
                // Get the value (aka. dictionary) of the scope
                var scopeVariables = currNode.Value;
                
                // Determine whether the variable exists in the scope
                // Stop the loop if the variable has been found in the current scope
                if (scopeVariables.ContainsKey(variableName))
                {
                    variableProperties = scopeVariables[variableName];
                    break;
                }

                // If there exists no previous node, stop the loop
                if (currNode.Previous == null)
                    break;

                currNode = currNode.Previous;
            }

            // Simply return, as variable properties may or may not be null
            return variableProperties;
        }

        VariableProperties GetDeclaredVariableInClassScope(string variableName)
        {
            // Create variableproperties var for storing the potential class variable
            VariableProperties variableProperties = null;

            if (_classScopeVariablesDictionary.ContainsKey(variableName))
                variableProperties = _classScopeVariablesDictionary[variableName];

            // Return either null or the variable's properties
            return variableProperties;
        }

        bool AddToExpressionStore(string parameterType)
        {
            // Empty string means something is wrong
            if (parameterType == "")
                return false;

            if (_expressionStore.ExpressionTypes.Count > 0)
            {
                var prevExpressionStoreString = _expressionStore.ExpressionTypes.Last.Previous.Value;

                switch (prevExpressionStoreString)
                {
                    case "text":
                        Console.WriteLine("text");
                        break;

                    case "number":
                        Console.WriteLine("number");
                        break;

                    case "bool":
                        Console.WriteLine("bool");
                        break;

                    case "void":
                        return false;
                }

            }

            return true;
        }

        string GetParameterType(object context, CBluntParser.ParameterContext parameter)
        {
            var assignmentType = "";

            if (parameter.STRING() != null)
                assignmentType = "text";

            if (parameter.NUMBER() != null)
                assignmentType = "number";

            if (parameter.truth() != null)
                assignmentType = "bool";

            if (parameter.ID() != null)
            {
                var variableName = parameter.ID().GetText();

                var assignmentVariableProperties = GetDeclaredVariable(parameter.ID().GetText());

                if (assignmentVariableProperties == null)
                {
                    SyntaxError(context, "Variable " + variableName + " does not exist");
                    return "";
                }

                // Determine whether the variable we are trying to assign has been initialized
                // We can assign an initialized variable to an uninitialized, but not an uninitialized variable to an initialized variable
                if (!assignmentVariableProperties.Initialized)
                {
                    SyntaxError(context, "Variable " + variableName + " has not been initialized yet");
                    return "";
                }

                // If all checks passes, grab the assignment type
                assignmentType = assignmentVariableProperties.Type;
            }

            if (parameter.functioncall() != null)
            {
                // Visit the functioncall for potential recursive handling. If it returns 1 it means that an error has occured and
                // checking should stop
                if (Visit(parameter.functioncall()) == 1)
                    return "";

                /// TODO: Maybe move the part below this up above the Visit
                var methodProperties = GetMethodProperties(parameter.functioncall().ID().GetText());

                if (methodProperties == null)
                {
                    SyntaxError(context, "Method with name " + parameter.functioncall().ID().GetText() + " does not exist");
                    return "";
                }

                assignmentType = methodProperties.Type;
            }

            return assignmentType;
        }

        /*
         *  Determine whether a method exists.
         */
        bool FindMethod(string methodName)
        {
            return GetMethodProperties(methodName) != null;
        }

        /*
         * A helper method for checking if a variable is declared at all
         */
        bool FindDeclaredVariable(string variableName)
        {
            return FindDeclaredVariableInMethodScope(variableName) || FindDeclaredVariableInClassScope(variableName);
        }

        /*
         * A helper method for checking if a method is declared in class scope
         */
        bool FindDeclaredVariableInClassScope(string variableName)
        {
            return GetDeclaredVariableInClassScope(variableName) != null;
        }

        /*
         * A method for simplifying finding declared variables in the scope of a method (skipping class scope)
         */
        bool FindDeclaredVariableInMethodScope(string variableName)
        {
            return GetDeclaredVariableInMethodScope(variableName) != null;
        }
    }
}