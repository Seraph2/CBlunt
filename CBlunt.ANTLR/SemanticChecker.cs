using System;
using System.Collections.Generic;
using System.Linq;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using CBlunt.ANTLR.AutoGeneratedParser;
using System.Reflection;

namespace CBlunt.ANTLR
{
    class SemanticChecker : CBluntBaseVisitor<int>
    {
        private Dictionary<string, VariableProperties> _classScopeVariablesDictionary = new Dictionary<string, VariableProperties>();
        private LinkedList<Dictionary<string, VariableProperties>> _methodScopeLinkedList = new LinkedList<Dictionary<string, VariableProperties>>();

        void SyntaxError(object context, string err)
        {
            var errLine = (int)GetPropertyValue(GetPropertyValue(context, "Start"), "Line");

            Console.WriteLine("Syntax error on line " + errLine + "! " + err);
        }

        public object GetPropertyValue(object obj, string propertyName)
        {
            var objType = obj.GetType();
            var prop = objType.GetProperty(propertyName);

            return prop.GetValue(obj, null);
        }

        public override int VisitStart([NotNull]CBluntParser.StartContext context)
        {
#if DEBUG
            Console.WriteLine("Beginning semantic checking");
            Console.WriteLine("VisitStart");
#endif

            // Start by visiting declarations. This is done because of the global scope
            for (int i = 0; i < context.declaration().Count(); ++i)
                Visit(context.declaration(i));

            // Then begin visiting methods
            for (int i = 0; i < context.function().Count(); ++i)
                Visit(context.function(i));

#if DEBUG
            Console.WriteLine("Finished semantic checking");
#endif

            return 0;
        }

        public override int VisitDeclaration([NotNull]CBluntParser.DeclarationContext context)
        {
#if DEBUG
            Console.WriteLine("VisitDeclaration");
#endif
            // Get the variable's type. We do not need to check if the variable's type is correct because that has already been done by the parser
            var variableType = context.variabletype().GetText();

            // Get the variable's name
            var variableName = context.ID().GetText();

            // Get the variable's value if it exists. A context with 4 children is a declaration followed by an assignment
            var variableValue = context.expression()?.GetText();

            // Get the parent index of this visitor
            var parentRuleIndex = context.Parent.RuleIndex;

            // If the parent's rule is "start", the declared variable needs to be added to the class scope, otherwise we add it to the method's scope
            if (parentRuleIndex == CBluntParser.RULE_start)
            {
                // Check whether the variable exists already in the class scope. Give an error if it does so
                if (FindDeclaredVariableInClassScope(variableName))
                {
                    SyntaxError(context, "Variable with name " + variableName + " already exists");
                    return 1;
                }
            }
            else
            {
                // Check whether the variable already exists in the method scope
                if (FindDeclaredVariableInMethodScope(variableName))
                {
                    SyntaxError(context, "Variable with name " + variableName + " already exists in current or parent scope");
                    return 1;
                }
            }

            // If no expression is found, simply create the variable and return as the variable cannot be type-checked against
            if (context.expression() == null)
            {
                CreateVariable(parentRuleIndex, variableName, variableType, variableValue);
                return 0;
            }

            // Simplify retrieval of the expression's parameter using a variable. Note that this does not properly handle the grammar's way, as I intentionally omit "calculation*" for testing purposes
            var contextExpressionParameter = context.expression().parameter();

            /// TODO: It may be necessary to determine a better way to do this, potentially utilizing visitor more correctly as this MAY complicate things later
            string foundParameterType = "";

            // Get the name of the expected parameter for potential error output further below
            if (contextExpressionParameter.STRING() != null)
                foundParameterType = "text";

            if (contextExpressionParameter.NUMBER() != null)
                foundParameterType = "number";

            if (contextExpressionParameter.truth() != null)
                foundParameterType = "bool";

            if (contextExpressionParameter.ID() != null)
            {
                var variablePropeties = GetDeclaredVariable(contextExpressionParameter.ID().GetText());

                if (variablePropeties == null)
                    return 1;

                if (!variablePropeties.Initialized)
                {
                    SyntaxError(context, "Cannot assign the value of variable " + contextExpressionParameter.ID().GetText() + " to variable " + variableName + " as it has not been initialized yet.");
                    return 1;
                }

                foundParameterType = variablePropeties.Type;
            }

            if (contextExpressionParameter.functioncall() != null)
            {
                // The name of the method
                var methodName = contextExpressionParameter.functioncall().ID().GetText();

                // If the visitor returns 1, there was a problem. Stop declaration check.
                if (Visit(contextExpressionParameter.functioncall()) == 1)
                    return 1;

                // Set the expected parameter type to the method's properties
                var methodProperties = GetMethodProperties(methodName);

                if (methodProperties == null)
                {
                    SyntaxError(context, "Attempt to get method " + methodName + " that does not exist");
                    return 1;
                }

                foundParameterType = methodProperties.Type;
            }

            // Check the variable's type with the found type
            if (variableType != foundParameterType)
            {
                SyntaxError(context, "Expected " + variableType + ", got " + foundParameterType);
                return 1;
            }

            CreateVariable(parentRuleIndex, variableName, variableType, variableValue);

            return 0;
        }

        public override int VisitFunction([NotNull]CBluntParser.FunctionContext context)
        {
#if DEBUG
            Console.WriteLine("VisitFunction");
#endif

            // Create a new scope to the linked list
            _methodScopeLinkedList.AddLast(new Dictionary<string, VariableProperties>());

            // Get the method's type
            var methodType = context.functiontype().GetText();

            // Get the method's name
            var methodName = context.ID(0).GetText();

            // Create the actual properties for the method
            MethodProperties methodProperties = new MethodProperties
            {
                // Set the type of the method
                Type = methodType,

                // Create the parameter types list for parsing of the method's parameters
                ParameterTypes = new List<string>()
            };

            // Check whether the method contains parameters. If so, add the parameter types to the methodProperties and add the variables
            // to the main scope of the method
            for (int i = 0; i < context.variabletype().Count(); ++i)
            {
                // Get the parameter's type
                var parameterType = context.variabletype(i).GetText();

                // Get the parameter's name. This is +1 due to that the first ID is the method's name
                var parameterName = context.ID(i + 1).GetText();

                // Add the parameter type to the list of parameter types
                methodProperties.ParameterTypes.Add(parameterType);

                // All parameters are guranteed to be initialized, set the initialized flag
                var variableProperties = new VariableProperties(parameterType)
                {
                    Initialized = true
                };

                // Add the variable along with properties to the method scope
                _methodScopeLinkedList.Last.Value.Add(parameterName, variableProperties);
            }

            // Visit the block of the function
            Visit(context.block());

            // Remove the scope
            _methodScopeLinkedList.RemoveLast();

            return 0;
        }

        public override int VisitBlock([NotNull]CBluntParser.BlockContext context)
        {
#if DEBUG
            Console.WriteLine("VisitBlock");
#endif

             // Iterate over all potential statements in the block. There can be 0 statements here
            for (var i = 0; i < context.statement().Count(); ++i)
            {
                Visit(context.statement(i));
            }

            return 0;
        }

        public override int VisitExpression([NotNull]CBluntParser.ExpressionContext context)
        {
#if DEBUG
            Console.WriteLine("VisitExpression");
#endif

            /// TODO: HANDLE RECURSION HERE

            if (context.parameter() != null)
                Visit(context.parameter());

            /*if (context.calculation() != null)
                Visit(context.calculation(0));*/

            return 0;
        }

        public override int VisitParameter([NotNull]CBluntParser.ParameterContext context)
        {
#if DEBUG
            Console.WriteLine("VisitParameter");
#endif

            if (context.ID() != null)
            {
                
            }

            return 0;
        }

        public override int VisitVariableedit([NotNull] CBluntParser.VariableeditContext context)
        {
#if DEBUG
            Console.WriteLine("VisitVariableedit");
#endif
            // The name of the variable
            var variableName = context.ID().GetText();

            // The operator type (For example: = += /= so on)
            var operatorType = context.equals().GetText();

            // The assignment value
            var assignmentValue = context.expression().GetText();

            /// TODO: USE UTILITY METHOD

            // First iterate over the current scope and all previous scopes
            var currNode = _methodScopeLinkedList.Last;

            // The properties of the variable we found
            VariableProperties variableProperties = null;

            variableProperties = GetDeclaredVariable(variableName);

            if (variableProperties == null)
            {
                SyntaxError(context, "Variable with name " + variableName + " cannot be assigned a value as it does not exist");
                return 1;
            }

            // Get the expected assignment value, aka the value we expect the variable to be assigned
            var expressionParameter = context.expression().parameter();
            var assignmentType = "";

            if (expressionParameter.STRING() != null)
                assignmentType = "text";

            if (expressionParameter.NUMBER() != null)
                assignmentType = "number";

            if (expressionParameter.truth() != null)
                assignmentType = "bool";

            if (expressionParameter.ID() != null)
            {
                var assignmentVariableProperties = GetDeclaredVariable(expressionParameter.ID().GetText());

                if (assignmentVariableProperties == null)
                {
                    SyntaxError(context, "Cannot assign the value of variable " + expressionParameter.ID().GetText() + " to variable " + variableName + " as it does not exist");
                    return 1;
                }

                // Determine whether the variable we are trying to assign has been initialized
                // We can assign an initialized variable to an uninitialized, but not an uninitialized variable to an initialized variable
                if (!assignmentVariableProperties.Initialized)
                {
                    SyntaxError(context, "Cannot assign the value of variable " + expressionParameter.ID().GetText() + " to variable " + variableName + " as it has not been initialized yet");
                    return 1;
                }

                assignmentType = assignmentVariableProperties.Type;
            }

            if (expressionParameter.functioncall() != null)
            {
                // Visit the functioncall for potential recursive handling. If it returns 1 it means that an error has occured and
                // checking should stop
                if (Visit(expressionParameter.functioncall()) == 1)
                    return 1;

                var methodProperties = GetMethodProperties(expressionParameter.functioncall().ID().GetText());

                if (methodProperties == null)
                {
                    SyntaxError(context, "Method with name " + expressionParameter.functioncall().ID().GetText() + " does not exist");
                    return 1;
                }

                assignmentType = methodProperties.Type;
            }

            switch (operatorType)
            {
                // Always allow default assignment
                case "=":
                    break;

                case "+=":
                    if (assignmentType != "number")
                    {
                        SyntaxError(context, "Cannot use addition assignment operator on a type " + assignmentType);
                        return 1;
                    }
                    break;

                case "-=":
                    if (assignmentType != "number")
                    {
                        SyntaxError(context, "Cannot use subtraction assignment operator on a type " + assignmentType);
                        return 1;
                    }
                    break;

                case "*=":
                    if (assignmentType != "number")
                    {
                        SyntaxError(context, "Cannot use multiplication assignment operator on a type " + assignmentType);
                        return 1;
                    }
                    break;

                case "/=":
                    if (assignmentType != "number")
                    {
                        SyntaxError(context, "Cannot use division assignment operator on a type " + assignmentType);
                        return 1;
                    }
                    break;
            }

            // Now test if this variable's type is the type it tries to assign
            if (variableProperties.Type != assignmentType)
            {
                SyntaxError(context, "Variable " + variableName + " is of type " + variableProperties.Type + ", cannot assign it a value of type " + assignmentType);
                return 1;
            }

            // If all checks passes, variable is correctly initialized
            variableProperties.Initialized = true;

            return base.VisitVariableedit(context);
        }

        public override int VisitStatement([NotNull] CBluntParser.StatementContext context)
        {
#if DEBUG
            Console.WriteLine("VisitStatement");
#endif
            /// TODO: Iterate as the rule requires it
            //Visit(context.functioncall());

            return base.VisitStatement(context);
        }

        public override int VisitFunctioncall([NotNull] CBluntParser.FunctioncallContext context)
        {
#if DEBUG
            Console.WriteLine("VisitFunctioncall");
#endif
            
            // The name of the method to call
            var methodName = context.ID().GetText();

            // This rule denotes a method call with nothing to return. Simple check to see if the method even exists.
            if (!FindMethod(methodName))
            {
                SyntaxError(context, "Attempt to call method " + methodName + " that does not exist");
                return 1;
            }

            // Get the method's properties. No need for null-check as this method does in fact exist
            var methodProperties = GetMethodProperties(methodName);

            // If there exists expressions, and the method does not actually take any parameters, stop and give syntax error
            if (context.expression().Count() > 0 && methodProperties.ParameterTypes.Count == 0)
            {
                SyntaxError(context, "Method with name " + methodName + " does not take any parameters");
                return 1;
            }

            // Get the nice name for the method
            var methodNiceName = GetMethodNiceName(methodName, methodProperties.ParameterTypes);

            // Compare the method's parameters with the found parameters to see whether they match
            for (int i = 0; i < context.expression().Count(); ++i)
            {
                var parameterType = "";
                var parameterCount = i + 1;

                /// TODO: Handle calculation recursively
                var functionCallParameterType = context.expression(i).parameter();

                if (functionCallParameterType.STRING() != null)
                    parameterType = "text";

                if (functionCallParameterType.NUMBER() != null)
                    parameterType = "number";

                if (functionCallParameterType.truth() != null)
                    parameterType = "bool";

                // Get the variable, if null we return. Otherwise the variable's type is assigned
                if (functionCallParameterType.ID() != null)
                {
                    var variableProperties = GetDeclaredVariable(functionCallParameterType.GetText());

                    if (variableProperties == null)
                    {
                        SyntaxError(context, "Passed variable " + functionCallParameterType.GetText() + " as parameter " + parameterCount + " to method " + methodNiceName + " does not exist");
                        return 1;
                    }
                        

                    if (!variableProperties.Initialized)
                    {
                        SyntaxError(context, "Cannot pass variable " + functionCallParameterType.GetText() + " to method " + methodName + " as it has not been initialized yet.");
                        return 1;
                    }

                    parameterType = variableProperties.Type;
                }
                
                if (functionCallParameterType.functioncall() != null)
                {
                    // Handle functioncall recursively
                    if (Visit(functionCallParameterType.functioncall()) == 1)
                        return 1;

                    var methodHere = GetMethodProperties(functionCallParameterType.functioncall().ID().GetText());

                    /// TODO: CORRECT ERROR HERE
                    if (methodHere == null)
                        return 1;

                    parameterType = methodHere.Type;
                }

                // If nothing matched, we got a problem
                if (parameterType == "")
                {
                    SyntaxError(context, "Nothing matched parameter number " + parameterCount + " for method " + methodNiceName);
                    Console.WriteLine("Houston, we got a problem");
                    return 1;
                }

                if (methodProperties.ParameterTypes.Count < parameterCount)
                {
                    SyntaxError(context, "Method " + methodNiceName + " does not take " + parameterCount + " parameters");
                    return 1;
                }

                var expectedMethodParameterType = methodProperties.ParameterTypes[i];

                if (expectedMethodParameterType != parameterType)
                {
                    SyntaxError(context, "Method " + methodNiceName + " got type " + parameterType + " as parameter number " + parameterCount + ", expected " + expectedMethodParameterType);
                    return 1;
                }
            }

            if (methodProperties.ParameterTypes.Count > context.expression().Count())
            {
                SyntaxError(context, "Method " + methodNiceName + " got " + context.expression().Count() + " parameters, expected " + methodProperties.ParameterTypes.Count);
                return 1;
            }

            return base.VisitFunctioncall(context);
        }

        /*
         * Create a variable in appropriate scope
         */
        void CreateVariable(int parentRuleIndex, string variableName, string variableType, string variableValue)
        {
            // Add the variable to the appropriate place
            if (parentRuleIndex == CBluntParser.RULE_start)
            {
                // Add the new variable to the class level and create variable properties for it
                _classScopeVariablesDictionary.Add(variableName, new VariableProperties(variableType, variableValue));
            }
            else
            {
                // Add the new variable to the last linked list node, and initialize a dictionary to it
                _methodScopeLinkedList.Last.Value.Add(variableName, new VariableProperties(variableType, variableValue));
            }
        }

        /*
         * Get a method as a nice name
         */
        string GetMethodNiceName(string methodName, List<string> methodParameters)
        {
            // Add a parenthese
            methodName += "(";

            // Only perform iteration if there actually exists parameters to this function
            if (methodParameters.Count > 0)
            {
                // Iterate over all types of found parameters, write its type along with a comma
                foreach (var paramType in methodParameters)
                    methodName += paramType + ",";

                // Remove the last comma
                methodName = methodName.Remove(methodName.Length - 1);
            }

            methodName += ")";

            return methodName;
        }

        /*
         * Get a method's properties
         */
        MethodProperties GetMethodProperties(string methodName)
        {
            if (SymbolTable.MethodDictionary.ContainsKey(methodName))
                return SymbolTable.MethodDictionary[methodName];

            return null;
        }

        /*
         * Get a declared variable in method scope first, then the class scope
         */
        VariableProperties GetDeclaredVariable(string variableName)
        {
            VariableProperties variableProperties = null;

            // Get the variable's properties from method scope
            variableProperties = GetDeclaredVariableInMethodScope(variableName);

            // If the variable's properties was not found, try the class scope
            if (variableProperties == null)
                variableProperties = GetDeclaredVariableInClassScope(variableName);

            return variableProperties;
        }

        VariableProperties GetDeclaredVariableInMethodScope(string variableName)
        {
            // Get the last node to iterate backwards over the linked list. Note that it is impossible for the linked list to be empty initially
            var currNode = _methodScopeLinkedList.Last;

            VariableProperties variableProperties = null;

            // This loop will ALWAYS end, as it is certain there will exist at least 1 node, and a node will always have an end, aka. previous == null. Should there somehow not exist such a node (for debugging maybe), it will give an error
            // We need to iterate over all previous scopes and see if the variable is declared as that is not allowed in C#
            while (true)
            {
                // Get the value (aka. dictionary) of the scope
                var scopeVariables = currNode.Value;

                // Stop the loop if the variable has been found in the current scope
                if (scopeVariables.ContainsKey(variableName))
                {
                    variableProperties = scopeVariables[variableName];
                    break;
                }

                // If there exists no previous node, stop the loop
                if (currNode.Previous == null)
                    break;

                currNode = currNode.Previous;
            }

            // Simply return as variable properties may or may not be null
            return variableProperties;
        }

        VariableProperties GetDeclaredVariableInClassScope(string variableName)
        {
            // Create variableproperties file for storing the potential class variable
            VariableProperties variableProperties = null;

            if (_classScopeVariablesDictionary.ContainsKey(variableName))
                variableProperties = _classScopeVariablesDictionary[variableName];

            // Return either null or the variable's properties
            return variableProperties;
        }

        /*
         *  Determine whether a method exists.
         */
        bool FindMethod(string methodName)
        {
            return GetMethodProperties(methodName) != null;
        }

        /*
         * A helper method for checking if a variable is declared at all
         */
        bool FindDeclaredVariable(string variableName)
        {
            return FindDeclaredVariableInMethodScope(variableName) || FindDeclaredVariableInClassScope(variableName);
        }

        /*
         * A helper metohod for checking if a method is declared in class scope
         */
        bool FindDeclaredVariableInClassScope(string variableName)
        {
            return GetDeclaredVariableInClassScope(variableName) != null;
        }

        /*
         * A method for simplifying finding declared variables in the scope of a method (skipping class scope)
         */
        bool FindDeclaredVariableInMethodScope(string variableName)
        {
            return GetDeclaredVariableInMethodScope(variableName) != null;
        }
    }
}