using System;
using System.Collections.Generic;
using System.Linq;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using CBlunt.ANTLR.AutoGeneratedParser;

namespace CBlunt.ANTLR
{
    class CBluntSemanticChecker : CBluntBaseVisitor<int>
    {
        private readonly Dictionary<string, Dictionary<string, string>> _variableDictionary = new Dictionary<string, Dictionary<string, string>>();

        public override int VisitStart([NotNull]CBluntParser.StartContext context)
        {
#if DEBUG
            Console.WriteLine("Beginning semantic checking");
            Console.WriteLine("VisitStart");
#endif

            /// TODO: Find a more elegant way to do this

            for (var i = 0; i < context.ChildCount; ++i)
            {
                if (context.declaration(i) != null)
                    Visit(context.declaration(i));
                    
                if (context.function(i) != null)
                    Visit(context.function(i));
            }

#if DEBUG
            Console.WriteLine("Finished semantic checking");
#endif

            return 0;
        }

        public override int VisitDeclaration([NotNull]CBluntParser.DeclarationContext context)
        {
#if DEBUG
            Console.WriteLine("VisitDeclaration");
#endif

            // Get the variabletype from text to a string variable. We do not need to determine if the variabletype is correct because that has already been done by the parser
            var variableType = context.variabletype().GetText();

            // If no expression is found, create the variable from the variableType with no value (null) and return, as to prevent parsing "expression"
            if (context.expression() == null) 
            {
                // Create variable with null value here

                return 0;
            }

            // Simplify retrieval of the expression's parameter using a variable. Note that this does not properly handle the grammar's way, as I intentionally omit "calculation*" for testing purposes
            var contextExpressionParameter = context.expression().parameter();

            /// TODO: It may be necessary to determine a better way to do this, potentially utilizing visitor more correctly as this MAY complicate things later
            string expectedParameterType = "";

            // Get the name of the expected parameter for potential error output further below
            if (contextExpressionParameter.STRING() != null)
                expectedParameterType = "text";
            else
            if (contextExpressionParameter.NUMBER() != null)
                expectedParameterType = "number";
            else
            if (contextExpressionParameter.TRUTH() != null)
            {
                expectedParameterType = "truth";
                Console.WriteLine("TRUTH matched!");
            }
            else
            if (contextExpressionParameter.ID() != null)
                 /// TODO: ID requires specialized handling as it first has to be evaluated if the ID even exists, and what the type of ID is.
                expectedParameterType = "id";
            else
            if (contextExpressionParameter.functioncall() != null)
            {
                /// TODO: Add functioncall
            }

             // Evaluation of ID is here because we can simply stop if the ID exists and is of the same type. This can only be done when registering of variables is done
            if (expectedParameterType == "id")
            {

            }

            // Default case is omitted because it is not possible due to the parser
            switch (variableType)
            {
                case "text":
                    if (contextExpressionParameter.STRING() == null)
                        Console.WriteLine("Syntax error on line " + context.Start.Line + "! Expected text, got " + expectedParameterType);
                    break;

                case "number":
                    if (contextExpressionParameter.NUMBER() == null)
                        Console.WriteLine("Syntax error on line " + context.Start.Line + "! Expected number, got " + expectedParameterType);
                    break;

                case "bool":
                    if (contextExpressionParameter.TRUTH() == null)
                        Console.WriteLine("Syntax error on line " + context.Start.Line + "! Expected bool, got " + expectedParameterType);
                    break;
            }

            return 0;
        }

        public override int VisitFunction([NotNull]CBluntParser.FunctionContext context)
        {
#if DEBUG
            Console.WriteLine("VisitFunction");
#endif

            Visit(context.block());

            return 0;
        }

        public override int VisitBlock([NotNull]CBluntParser.BlockContext context)
        {
#if DEBUG
            Console.WriteLine("VisitFunction");
#endif

             // Iterate over all potential statements in the block. There can be 0 statements here
            for (var i = 0; i < context.ChildCount; ++i)
            {
                if (context.statement(i) != null)
                    Visit(context.statement(i));
            }

            return 0;
        }

        public override int VisitExpression([NotNull]CBluntParser.ExpressionContext context)
        {
#if DEBUG
            Console.WriteLine("VisitExpression");
#endif
            if (context.parameter() != null)
                Visit(context.parameter());

            /*if (context.calculation() != null)
                Visit(context.calculation(0));*/

            return 0;
        }

        public override int VisitParameter([NotNull]CBluntParser.ParameterContext context)
        {
#if DEBUG
            Console.WriteLine("VisitParameter");
#endif

            if (context.ID() != null)
            {
                
            }

            return 0;
        }
    }
}
