using System;
using System.Collections.Generic;
using System.Linq;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using CBlunt.ANTLR.AutoGeneratedParser;
using System.Reflection;

namespace CBlunt.ANTLR
{
    class SemanticChecker : CBluntBaseVisitor<int>
    {
        private readonly Dictionary<string, VariableProperties> _classScopeVariablesDictionary = new Dictionary<string, VariableProperties>();
        private readonly LinkedList<Dictionary<string, VariableProperties>> _methodScopeLinkedList = new LinkedList<Dictionary<string, VariableProperties>>();
        private readonly LinkedList<ExpressionStore> _expressionStore = new LinkedList<ExpressionStore>();
        private string _currentMethodType = "";

        void SyntaxError(object context, string err)
        {
            var errLine = (int)GetPropertyValue(GetPropertyValue(context, "Start"), "Line");

            Console.WriteLine("Syntax error on line " + errLine + "! " + err);
        }

        public object GetPropertyValue(object obj, string propertyName)
        {
            var objType = obj.GetType();
            var prop = objType.GetProperty(propertyName);

            return prop.GetValue(obj, null);
        }

        public override int VisitStart([NotNull]CBluntParser.StartContext context)
        {
#if DEBUG
            Console.WriteLine("Beginning semantic checking");
            Console.WriteLine("VisitStart");
#endif

            // Determine whether the entry point exists
            var mainMethodProperties = GetMethodProperties("Main");

            if (mainMethodProperties == null)
            {
                Console.WriteLine("Syntax error! There must exists a method with following properties: void Main() { }");
                return 1;
            }

            if (mainMethodProperties.Type != "void")
            {
                Console.WriteLine("Syntax error! There must exists a method with following properties: void Main() { }");
                return 1;
            }

#if DEBUG
            Console.WriteLine("Finished semantic checking");
#endif

            return base.VisitStart(context);
        }

        public override int VisitDeclaration([NotNull]CBluntParser.DeclarationContext context)
        {
#if DEBUG
            Console.WriteLine("VisitDeclaration");
#endif
            // Get the variable's type. We do not need to check if the variable's type is correct because that has already been done by the parser
            var variableType = context.variabletype().GetText();

            // Get the variable's name
            var variableName = context.ID().GetText();

            // Get the variable's value if it exists. A context with 4 children is a declaration followed by an assignment
            var variableValue = context.expression()?.GetText();

            // Get the parent index of this visitor
            var parentRuleIndex = context.Parent.RuleIndex;

            // If the parent's rule is "start", the declared variable needs to be added to the class scope, otherwise we add it to the method's scope
            if (parentRuleIndex == CBluntParser.RULE_start)
            {
                // Check whether the variable exists already in the class scope. Give an error if it does so
                if (FindDeclaredVariableInClassScope(variableName))
                {
                    SyntaxError(context, "Variable with name " + variableName + " already exists");
                    return 1;
                }
            }
            else
            {
                // Check whether the variable already exists in the method scope
                if (FindDeclaredVariableInMethodScope(variableName))
                {
                    SyntaxError(context, "Variable with name " + variableName + " already exists in current or parent scope");
                    return 1;
                }
            }

            // If no expression is found, simply create the variable and return as the variable cannot be type-checked against
            // Example: text a;
            if (context.expression() == null)
            {
                CreateVariable(parentRuleIndex, variableName, variableType, variableValue);
                return 0;
            }

            _expressionStore.AddLast(new ExpressionStore());

            // Visit the expression
            Visit(context.expression());

            // Set the found parameter type
            var foundParameterType = _expressionStore.Last.Value.Type;

            _expressionStore.RemoveLast();

            // Check the variable's type against the found type
            if (variableType != foundParameterType)
            {
                SyntaxError(context, "Expected " + variableType + ", got " + foundParameterType);
                return 1;
            }

            CreateVariable(parentRuleIndex, variableName, variableType, variableValue);

            return 0;
        }

        public override int VisitFunction([NotNull]CBluntParser.FunctionContext context)
        {
#if DEBUG
            Console.WriteLine("VisitFunction");
#endif

            // Create a new scope to the linked list
            _methodScopeLinkedList.AddLast(new Dictionary<string, VariableProperties>());

            // Get the method's type
            var methodType = context.functiontype().GetText();

            // Get the method's name
            var methodName = context.ID(0).GetText();

            // Create the actual properties for the method
            MethodProperties methodProperties = new MethodProperties
            {
                // Set the type of the method
                Type = methodType,

                // Create the parameter types list for parsing of the method's parameters
                ParameterTypes = new List<string>()
            };

            // Check whether the method contains parameters. If so, add the parameter types to the methodProperties and add the variables
            // to the main scope of the method
            for (int i = 0; i < context.variabletype().Count(); ++i)
            {
                // Get the parameter's type
                var parameterType = context.variabletype(i).GetText();

                // Get the parameter's name. This is +1 due to that the first ID is the method's name
                var parameterName = context.ID(i + 1).GetText();

                // Add the parameter type to the list of parameter types
                methodProperties.ParameterTypes.Add(parameterType);

                // All parameters are guranteed to be initialized, set the initialized flag
                var variableProperties = new VariableProperties(parameterType)
                {
                    Initialized = true
                };

                // Add the variable along with properties to the method scope
                _methodScopeLinkedList.Last.Value.Add(parameterName, variableProperties);
            }

            _currentMethodType = methodType;

            // Visit the block of the method
            Visit(context.block());

            // After the function has finished, remove the scope
            _methodScopeLinkedList.RemoveLast();

            return 0;
        }

        public override int VisitBlock([NotNull] CBluntParser.BlockContext context)
        {
#if DEBUG
            Console.WriteLine("VisitBlock");
#endif

            if (context.Parent.RuleIndex != CBluntParser.RULE_function)
                _methodScopeLinkedList.AddLast(new Dictionary<string, VariableProperties>());

            // In the initial scope of the method, check whether there exists at least one return. Error if there exists multiple
            int returnCount = 0;

            for (int i = 0; i < context.statement().Count(); ++i)
            {
                // Skip non-function returns
                if (context.statement(i).functionreturn() == null)
                {
                    Visit(context.statement(i));
                    continue;
                }

                // Cannot break here as there MAY exist multiple returns
                ++returnCount;

                // Check for void: it cannot return anything
                if (context.statement(i).functionreturn().expression() != null && _currentMethodType == "void")
                {
                    SyntaxError(context, "Void methods cannot return values");
                    return 1;
                }

                // Check for non-void: it MUST return something
                if (context.statement(i).functionreturn().expression() == null && _currentMethodType != "void")
                {
                    SyntaxError(context, "Method " + _currentMethodType + " with type " + _currentMethodType + " must return a value");
                    return 1;
                }

                // If there exists multiple returns, there is a problem. This accounts for both void and other types
                if (returnCount > 1)
                {
                    SyntaxError(context, "Method " + _currentMethodType + " with type " + _currentMethodType + " cannot return multiple times in its method scope");
                    return 1;
                }

                // Initial checks done, now expression has to be visited to determine the return type according to method type
                // void can of course be skipped
                if (_currentMethodType == "void")
                    continue;

                // Add to the expression store
                _expressionStore.AddLast(new ExpressionStore());

                // Get the type returned
                Visit(context.statement(i).functionreturn().expression());

                var returnType = _expressionStore.Last.Value.Type;

                if (_currentMethodType != returnType)
                {
                    SyntaxError(context, "A type " + returnType + " is returned, a type " + _currentMethodType + " was expected to be returned instead");
                    return 1;
                }

                _expressionStore.RemoveLast();

            }

            // If there exists no return and it is NOT a method of type void, output an error
            if (returnCount == 0 && _currentMethodType != "void" && _methodScopeLinkedList.Count == 1)
            {
                SyntaxError(context, "Method " + _currentMethodType + " with type " + _currentMethodType + " does not return a type " + _currentMethodType);
                return 1;
            }

            if (context.Parent.RuleIndex != CBluntParser.RULE_function)
                _methodScopeLinkedList.RemoveLast();

            return 0;
        }

        public override int VisitExpression([NotNull]CBluntParser.ExpressionContext context)
        {
#if DEBUG
            Console.WriteLine("VisitExpression");
#endif

            var parameter = context.parameter();
            var assignmentType = GetParameterType(context, parameter);

            if (!AddToExpressionStore(assignmentType))
                return 1;

            var calculationCount = context.calculation().Count();

            // With no calculations, it is simply the assignment type
            if (calculationCount == 0)
            {
                _expressionStore.Last.Value.Type = assignmentType;
                return 0;
            }

            for (int i = 0; i < calculationCount; ++i)
            {
                if (Visit(context.calculation(i)) == 1)
                    return 1;
            }

            return 0;
        }

        public override int VisitCalculation([NotNull] CBluntParser.CalculationContext context)
        {
#if DEBUG
            Console.WriteLine("VisitCalculation");
#endif

            var operatorContext = context.@operator().GetText();

            // If a parameter was found, add it to the store
            if (context.parameter() != null)
            {
                var parameter = context.parameter();
                var parameterType = GetParameterType(context, parameter);

                var prevExpressionStoreType = _expressionStore.Last.Value.ExpressionTypes.Last;

                if (prevExpressionStoreType == null)
                {
                    Console.WriteLine(1);
                    if (!AddToExpressionStore(parameterType))
                        return 1;

                    return 0;
                }

                var prevExpressionStoreValue = prevExpressionStoreType.Value;

                // Perform semantics on operator, it is not possible to subtract ex. a string from a number
                // If the type is already text, the numbers cannot turn the expression store into a number again. It will remain text
                switch (operatorContext)
                {
                    case "+":
                        if (prevExpressionStoreValue == "number" && parameterType == "number")
                        {
                            if (_expressionStore.Last.Value.Type == "text")
                                break;

                            _expressionStore.Last.Value.Type = "number";
                            break;
                        }

                        if (prevExpressionStoreValue == "text" && parameterType == "text")
                        {
                            _expressionStore.Last.Value.Type = "text";
                            break;
                        }
                            

                        if (prevExpressionStoreValue == "number" && parameterType == "text")
                        {
                            _expressionStore.Last.Value.Type = "text";
                            break;
                        }

                        if (prevExpressionStoreValue == "text" && parameterType == "number")
                        {
                            _expressionStore.Last.Value.Type = "text";
                            break;
                        }

                        SyntaxError(context, "Cannot add a variable of type " + prevExpressionStoreValue + " with a variable of type " + parameterType);
                        return 1;

                    case "-":
                        if (prevExpressionStoreValue == "number" && parameterType == "number")
                        {
                            if (_expressionStore.Last.Value.Type == "text")
                                break;

                            _expressionStore.Last.Value.Type = "number";
                            break;
                        }

                        SyntaxError(context, "Cannot subtract a variable of type " + prevExpressionStoreValue + " with a variable of type " + parameterType);
                        return 1;

                    case "*":
                        if (prevExpressionStoreValue == "number" && parameterType == "number")
                        {
                            if (_expressionStore.Last.Value.Type == "text")
                                break;

                            _expressionStore.Last.Value.Type = "number";
                            break;
                        }

                        SyntaxError(context, "Cannot multiply a variable of type " + prevExpressionStoreValue + " with a variable of type " + parameterType);
                        return 1;

                    case "/":
                        if (prevExpressionStoreValue == "number" && parameterType == "number")
                        {
                            if (_expressionStore.Last.Value.Type == "text")
                                break;

                            _expressionStore.Last.Value.Type = "number";
                            break;
                        }

                        SyntaxError(context, "Cannot divide a variable of type " + prevExpressionStoreValue + " with a variable of type " + parameterType);
                        return 1;
                }

                if (!AddToExpressionStore(parameterType))
                    return 1;
            }

            // If there is an expression instead, visit it
            if (context.expression() != null)
            {
                if (Visit(context.expression()) == 1)
                    return 1;
            }
            
            return base.VisitCalculation(context);
        }

        public override int VisitParameter([NotNull]CBluntParser.ParameterContext context)
        {
#if DEBUG
            Console.WriteLine("VisitParameter");
#endif

            return 0;
        }

        public override int VisitVariableedit([NotNull] CBluntParser.VariableeditContext context)
        {
#if DEBUG
            Console.WriteLine("VisitVariableedit");
#endif
            // The name of the variable
            var variableName = context.ID().GetText();

            // The operator type (For example: = += /= so on)
            var operatorType = context.equals().GetText();

            // The assignment value
            var assignmentValue = context.expression().GetText();

            /// TODO: USE UTILITY METHOD

            // First iterate over the current scope and all previous scopes
            var currNode = _methodScopeLinkedList.Last;

            // The properties of the variable we found
            VariableProperties variableProperties = null;

            variableProperties = GetDeclaredVariable(variableName);

            if (variableProperties == null)
            {
                SyntaxError(context, "Variable with name " + variableName + " cannot be assigned a value as it does not exist");
                return 1;
            }

            // Get the expected assignment value, aka the value we expect the variable to be assigned
            _expressionStore.AddLast(new ExpressionStore());

            Visit(context.expression());

            // Set assignment type from expression, compare it against operator type
            var assignmentType = _expressionStore.Last.Value.Type;

            _expressionStore.RemoveLast();

            switch (operatorType)
            {
                // Always allow default assignment
                case "=":
                    break;

                case "+=":
                    if (assignmentType != "number")
                    {
                        SyntaxError(context, "Cannot use addition assignment operator on a type " + assignmentType);
                        return 1;
                    }
                    break;

                case "-=":
                    if (assignmentType != "number")
                    {
                        SyntaxError(context, "Cannot use subtraction assignment operator on a type " + assignmentType);
                        return 1;
                    }
                    break;

                case "*=":
                    if (assignmentType != "number")
                    {
                        SyntaxError(context, "Cannot use multiplication assignment operator on a type " + assignmentType);
                        return 1;
                    }
                    break;

                case "/=":
                    if (assignmentType != "number")
                    {
                        SyntaxError(context, "Cannot use division assignment operator on a type " + assignmentType);
                        return 1;
                    }
                    break;
            }

            // Now test if this variable's type is the type we are trying to assign
            if (variableProperties.Type != assignmentType)
            {
                SyntaxError(context, "Variable " + variableName + " is of type " + variableProperties.Type + ", cannot assign it a value of type " + assignmentType);
                return 1;
            }

            // If all checks passes, the variable will also be initialized
            variableProperties.Initialized = true;

            return 0;
        }

        public override int VisitStatement([NotNull] CBluntParser.StatementContext context)
        {
#if DEBUG
            Console.WriteLine("VisitStatement");
#endif
            /// TODO: Iterate as the rule requires it
            //Visit(context.functioncall());

            return base.VisitStatement(context);
        }

        public override int VisitFunctioncall([NotNull] CBluntParser.FunctioncallContext context)
        {
#if DEBUG
            Console.WriteLine("VisitFunctioncall");
#endif
            
            // The name of the method to call
            var methodName = context.ID().GetText();

            // Get the amout of expressions
            var expressionCount = context.expression().Count();

            // Get the method's properties
            var methodProperties = GetMethodProperties(methodName);

            // This rule denotes a method call with nothing to return. Simple check to see if the method even exists.
            if (methodProperties == null)
            {
                SyntaxError(context, "Attempt to call method " + methodName + " that does not exist");
                return 1;
            }

            // If there exists expressions, and the method does not actually take any parameters, stop and give syntax error
            if (expressionCount > 0 && methodProperties.ParameterTypes.Count == 0)
            {
                SyntaxError(context, "Method with name " + methodName + " does not take any parameters");
                return 1;
            }

            // Get the nice name for the method
            var methodNiceName = GetMethodNiceName(methodName, methodProperties.ParameterTypes);

            if (methodProperties.ParameterTypes.Count != expressionCount)
            {
                SyntaxError(context, "Method " + methodNiceName + " got " + expressionCount + " parameters, expected " + methodProperties.ParameterTypes.Count);
                return 1;
            }

            // Compare the method's parameters with the found parameters to see whether they match
            for (int i = 0; i < context.expression().Count(); ++i)
            {
                _expressionStore.AddLast(new ExpressionStore());

                Visit(context.expression(i));

                var parameterCount = i + 1;

                /// TODO: Potentially != here instead
                if (methodProperties.ParameterTypes.Count < parameterCount)
                {
                    SyntaxError(context, "Method " + methodNiceName + " does not take " + parameterCount + " parameters");
                    return 1;
                }

                // Get the expected parameter type from the method's properties
                var expectedParameterType = methodProperties.ParameterTypes[i];

                // Number has a ToString conversion, set appropriate type here if it is as such
                if (expectedParameterType == "text" && _expressionStore.Last.Value.Type == "number")
                    _expressionStore.Last.Value.Type = "text";

                // If it is not equal to the retrieved parameter type, be it variable, functioncall etc, an error is imminent
                if (expectedParameterType != _expressionStore.Last.Value.Type)
                {
                    SyntaxError(context, "Method " + methodNiceName + " got type " + _expressionStore.Last.Value.Type + " as parameter number " + parameterCount + ", expected " + expectedParameterType);
                    return 1;
                }

                _expressionStore.RemoveLast();
            }

            return 0;
        }

        public override int VisitLogic([NotNull] CBluntParser.LogicContext context)
        {
#if DEBUG
            Console.WriteLine("VisitLogic");
#endif

            // Get left-hand side
            _expressionStore.AddLast(new ExpressionStore());
            Visit(context.expression(0));
            var expr1Type = _expressionStore.Last.Value.Type;
            _expressionStore.RemoveLast();

            // Get right-hand side
            _expressionStore.AddLast(new ExpressionStore());
            Visit(context.expression(1));
            var expr2Type = _expressionStore.Last.Value.Type;
            _expressionStore.RemoveLast();

            if (expr1Type != "number")
            {
                SyntaxError(context, "Left-hand side must be of a type number");
                return 1;
            }

            if (expr2Type != "number")
            {
                SyntaxError(context, "Right-hand side must be of a type number");
                return 1;
            }

            return 0;
        }

        public override int VisitCondition([NotNull] CBluntParser.ConditionContext context)
        {
            // Specialized handling for ID hence it is here
            if (context.ID() != null)
            {
                var variableName = context.ID().GetText();

                var variableProperties = GetDeclaredVariable(variableName);

                if (variableProperties == null)
                {
                    SyntaxError(context, "Variable " + variableName + " does not exist");
                    return 1;
                }

                if (!variableProperties.Initialized)
                {
                    SyntaxError(context, "Variable " + variableName + " has not been initialized");
                    return 1;
                }

                if (variableProperties.Type != "bool")
                {
                    SyntaxError(context, "Variable " + variableName + " must be of a type bool");
                    return 1;
                }
            }

            return base.VisitCondition(context);
        }

        public override int VisitFunctionreturn([NotNull] CBluntParser.FunctionreturnContext context)
        {
#if DEBUG
            Console.WriteLine("VisitFunctionreturn");
#endif

            /// TODO: Evaluate here whatever is attempted to return is correct according to the method's type

            return base.VisitFunctionreturn(context);
        }

        /*
         * Create a variable in its appropriate scope
         */
        void CreateVariable(int parentRuleIndex, string variableName, string variableType, string variableValue)
        {
            // Add the variable to the appropriate place
            if (parentRuleIndex == CBluntParser.RULE_start)
            {
                // Add the new variable to the class level and create variable properties for it
                _classScopeVariablesDictionary.Add(variableName, new VariableProperties(variableType, variableValue));
            }
            else
            {
                // Add the new variable to the last LinkedList node, and initialize a dictionary to it
                _methodScopeLinkedList.Last.Value.Add(variableName, new VariableProperties(variableType, variableValue));
            }
        }

        /*
         * Get a method as a nice name, ex: MethodHere(number,text,bool)
         */
        string GetMethodNiceName(string methodName, List<string> methodParameters)
        {
            // Add a parenthese
            methodName += "(";

            // Only perform iteration if there actually exists parameters to this function
            if (methodParameters.Count > 0)
            {
                // Iterate over all types of found parameters, write its type along with a comma
                foreach (var paramType in methodParameters)
                    methodName += paramType + ",";

                // Remove the last comma
                methodName = methodName.Remove(methodName.Length - 1);
            }

            methodName += ")";

            return methodName;
        }

        /*
         * Get a method's properties
         */
        MethodProperties GetMethodProperties(string methodName)
        {
            if (SymbolTable.MethodDictionary.ContainsKey(methodName))
                return SymbolTable.MethodDictionary[methodName];

            return null;
        }

        /*
         * Get a declared variable in method scope first, then the class scope
         */
        VariableProperties GetDeclaredVariable(string variableName)
        {
            // Get the variable's properties from method scope
            VariableProperties variableProperties = GetDeclaredVariableInMethodScope(variableName);

            // If the variable's properties was not found, try the class scope
            if (variableProperties == null)
                variableProperties = GetDeclaredVariableInClassScope(variableName);

            // Return the variable
            return variableProperties;
        }

        VariableProperties GetDeclaredVariableInMethodScope(string variableName)
        {
            // Get the last node to iterate backwards over the linked list. Note that it is impossible for the linked list to be empty initially
            var currNode = _methodScopeLinkedList.Last;

            // Create variable properties variable for storing the output
            VariableProperties variableProperties = null;

            // This loop will ALWAYS end, as it is certain there will exist at least 1 node, and a node will always have an end, aka. previous == null. Should there somehow not exist such a node (for debugging maybe), it will give an error
            // We need to iterate over all previous scopes and see if the variable is declared as that is not allowed in C#
            while (true)
            {
                // Get the value (aka. dictionary) of the scope
                var scopeVariables = currNode.Value;
                
                // Determine whether the variable exists in the scope
                // Stop the loop if the variable has been found in the current scope
                if (scopeVariables.ContainsKey(variableName))
                {
                    variableProperties = scopeVariables[variableName];
                    break;
                }

                // If there exists no previous node, stop the loop
                if (currNode.Previous == null)
                    break;

                currNode = currNode.Previous;
            }

            // Simply return, as variable properties may or may not be null
            return variableProperties;
        }

        VariableProperties GetDeclaredVariableInClassScope(string variableName)
        {
            // Create variableproperties var for storing the potential class variable
            VariableProperties variableProperties = null;

            if (_classScopeVariablesDictionary.ContainsKey(variableName))
                variableProperties = _classScopeVariablesDictionary[variableName];

            // Return either null or the variable's properties
            return variableProperties;
        }

        bool AddToExpressionStore(string parameterType)
        {
            // Empty string means something is wrong
            if (parameterType == "")
                return false;

            // Skip void completely, it cannot be used in an expression
            if (parameterType == "void")
                return false;

            // Variable for previous expression
            string prevExpressionStoreType = null;

            // If there exists a previous node, get its type
            if (_expressionStore.Last.Value.ExpressionTypes.Last != null)
                prevExpressionStoreType = _expressionStore.Last.Value.ExpressionTypes.Last.Value;

            // If there exists no previous expression, simply store the parameter type
            if (prevExpressionStoreType == null)
            {
                _expressionStore.Last.Value.ExpressionTypes.AddLast(parameterType);
                return true;
            }

            _expressionStore.Last.Value.ExpressionTypes.AddLast(parameterType);

            return true;
        }

        string GetParameterType(object context, CBluntParser.ParameterContext parameter)
        {
            var assignmentType = "";

            if (parameter.STRING() != null)
                assignmentType = "text";

            if (parameter.NUMBER() != null)
                assignmentType = "number";

            if (parameter.truth() != null)
                assignmentType = "bool";

            if (parameter.ID() != null)
            {
                var variableName = parameter.ID().GetText();

                var assignmentVariableProperties = GetDeclaredVariable(parameter.ID().GetText());

                if (assignmentVariableProperties == null)
                {
                    SyntaxError(context, "Variable " + variableName + " does not exist");
                    return "";
                }

                // Determine whether the variable we are trying to assign has been initialized
                // We can assign an initialized variable to an uninitialized, but not an uninitialized variable to an initialized variable
                if (!assignmentVariableProperties.Initialized)
                {
                    SyntaxError(context, "Variable " + variableName + " has not been initialized yet");
                    return "";
                }

                // If all checks passes, grab the assignment type
                assignmentType = assignmentVariableProperties.Type;
            }

            if (parameter.functioncall() != null)
            {
                // Visit the functioncall for potential recursive handling. If it returns 1 it means that an error has occured and
                // checking should stop
                if (Visit(parameter.functioncall()) == 1)
                    return "";

                /// TODO: Maybe move the part below this up above the Visit
                var methodProperties = GetMethodProperties(parameter.functioncall().ID().GetText());

                if (methodProperties == null)
                {
                    SyntaxError(context, "Method with name " + parameter.functioncall().ID().GetText() + " does not exist");
                    return "";
                }

                assignmentType = methodProperties.Type;
            }

            return assignmentType;
        }

        /*
         *  Determine whether a method exists.
         */
        bool FindMethod(string methodName)
        {
            return GetMethodProperties(methodName) != null;
        }

        /*
         * A helper method for checking if a variable is declared at all
         */
        bool FindDeclaredVariable(string variableName)
        {
            return FindDeclaredVariableInMethodScope(variableName) || FindDeclaredVariableInClassScope(variableName);
        }

        /*
         * A helper method for checking if a method is declared in class scope
         */
        bool FindDeclaredVariableInClassScope(string variableName)
        {
            return GetDeclaredVariableInClassScope(variableName) != null;
        }

        /*
         * A method for simplifying finding declared variables in the scope of a method (skipping class scope)
         */
        bool FindDeclaredVariableInMethodScope(string variableName)
        {
            return GetDeclaredVariableInMethodScope(variableName) != null;
        }
    }
}